<h1>PicoCTF - Obedient Cat</h1>
<h2>Problem:</h2>
<ul>
<li>This file has a flag in plain sight (aka "in-the-clear").</li>
</ul>
<h2>Hints:</h2>
<ol type="1">
<li>Any hints about entering a command into the Terminal (such as the
next one), will start with a '$'... everything after the dollar sign
will be typed (or copy and pasted) into your Terminal.</li>
</ol>
<ul>
<li>PicoCTF uses the common notation of <code>$</code> to prepend any
shell command.</li>
<li>This also comes with the meaning that the command should be run as a
regular user, and a <code>#</code> would be used if it was to be run as
root (or administrator). [0]</li>
</ul>
<ol start="2" type="1">
<li>To get the file accessible in your shell, enter the following in the
Terminal prompt: $ wget (site).</li>
</ol>
<ul>
<li>Picoctf suggests to use Wget to download content from it's remote
servers.</li>
<li>It also comes with many useful features to crawl websites and
download all referenced files. [1]</li>
<li>For most circumstances though, you will be fine just downloading it
through your web browser.</li>
</ul>
<ol start="3" type="1">
<li>$ man cat</li>
</ol>
<ul>
<li>"Man" is the unix command for manual pages, so this command brings
up the documentation for the cat command. [2]</li>
<li>The description given for the cat command is "concatenate files and
prnt on the standard output". [3]</li>
<li>Cat is commonly used for just reading simple files to the terminal
(STDOUT).</li>
</ul>
<h2>Solution:</h2>
<p>In an attempt to overcomplicate this, we will be building an
command-line-argument parser and will manually read and interpret the
file as bytes.</p>
<p>First and for most, we need to import all the modules we will be
using.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span>fs<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::path::</span><span class="op">{</span>Pathbuf<span class="op">};</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::env::</span><span class="op">{</span>args<span class="op">,</span> Args<span class="op">};</span></span></code></pre></div>
<p>First thing we need to do is get all the arguments passed to the CLI,
so we will use Rust's Args functions. Just like how hint number 3 says
<code>$ man cat</code>, we want to be able to run
<code>$ obedient_cat ~/file</code>. This means we will be expecting 2
inputs, the name of the program (0), and the path to the file (1).</p>
<p>To express this relationship, it would make sense for us to build a
struct.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Cli <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  program_name<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  path_to_file<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Next, we need to be able to build the CLI, and to do that, we can
impliemnt the From trait for the CLI. Rust's command line arguments are
accessed through the args() function, which returns an interator, type
Args, over a group of strings. The result would look something like
this:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="bu">From</span><span class="op">&lt;</span>Args<span class="op">&gt;</span> <span class="cf">for</span> Cli <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> from(<span class="kw">mut</span> args<span class="op">:</span> Args) <span class="op">-&gt;</span> Cli <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> program_name <span class="op">=</span> args<span class="op">.</span>next()<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> path_to_file <span class="op">=</span> args<span class="op">.</span>next()<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> args<span class="op">.</span>next() <span class="op">!=</span> <span class="cn">None</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Do not supply more than 2 command line arguments&quot;</span>)<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        Cli <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            program_name<span class="op">,</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            path_to_file</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The next function, when used on an iterator, returns Option<String>
for the current element and moves the cursor to the next element. Option
is Rust's analogue for many language's Nil or Null. An Option is either
<code>None</code> or <code>Some(T)</code>. In this circumstance, if the
iterator isn't empty, it will return the command line argument.</p>
<p>We do that twise, as the Args includes the calling of the original
function, and then we need to collect the path. There is no need to
worry about extra command line arguments being input, so we can just
print out a warning and not panic the whole program.</p>
<p>Now, lets build the main function.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> cli <span class="op">=</span> <span class="pp">Cli::</span>from(args())<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> cli<span class="op">.</span>program_name <span class="op">==</span> <span class="cn">None</span> <span class="op">{</span> <span class="pp">panic!</span>(<span class="st">&quot;Program Name Not Found&quot;</span> )<span class="op">;</span> <span class="op">}</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> cli<span class="op">.</span>path_to_file <span class="op">==</span> <span class="cn">None</span> <span class="op">{</span> <span class="pp">panic!</span>(<span class="st">&quot;Path To File Not Found&quot;</span> )<span class="op">;</span> <span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> path <span class="op">=</span> <span class="dt">PathBuf</span><span class="pp">::</span>from(cli<span class="op">.</span>path_to_file<span class="op">.</span>unwrap())</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>canonicalize()</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>expect(<span class="st">&quot;Path supplied is not a path&quot;</span>)<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> read_file(path))<span class="op">;</span>  </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>What we do here is first call our from function to build our CLI.
Then we do some quick sanity checks to verify that the arguments were
parsed correctly and were actually given.</p>
<p>We then create the PathBuffer, using the cli's path as it's input and
then canonicalizing it. Canonicalizing just returns the absolute and
completely resolved path, making it significantly easier to handle.
[#]</p>
<p>Then, we just plug that into our next function, read_file, and print
it out!</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> read_file(path<span class="op">:</span> Pathbuf) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="pp">fs::</span>read_to_string(path)<span class="op">.</span>expect(<span class="st">&quot;Couldn&#39;t read file&quot;</span>)<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>While you could theoretically inline this function, it makes it much
cleaner for the tests and calls to it. All it does is read the file of
the path and then return it as a String, as simple as that.</p>
<p>Finally, the tests.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> example_flag_1() <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> path<span class="op">:</span> <span class="dt">PathBuf</span> <span class="op">=</span> <span class="dt">PathBuf</span><span class="pp">::</span>from(<span class="pp">env!</span>(<span class="st">&quot;CARGO_MANIFEST_DIR&quot;</span>))<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        path<span class="op">.</span>push(<span class="st">&quot;tests/example1&quot;</span>)<span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(read_file(path)<span class="op">,</span> <span class="st">&quot;picoCTF{FakeFlag1}&quot;</span><span class="op">.</span>to_string())</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> example_flag_2() <span class="op">{</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> path<span class="op">:</span> <span class="dt">PathBuf</span> <span class="op">=</span> <span class="dt">PathBuf</span><span class="pp">::</span>from(<span class="pp">env!</span>(<span class="st">&quot;CARGO_MANIFEST_DIR&quot;</span>))<span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        path<span class="op">.</span>push(<span class="st">&quot;tests/example2&quot;</span>)<span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(read_file(path)<span class="op">,</span> <span class="st">&quot;{Testing,Testing}&quot;</span><span class="op">.</span>to_string())<span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> example_flag_3() <span class="op">{</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> path<span class="op">:</span> <span class="dt">PathBuf</span> <span class="op">=</span> <span class="dt">PathBuf</span><span class="pp">::</span>from(<span class="pp">env!</span>(<span class="st">&quot;CARGO_MANIFEST_DIR&quot;</span>))<span class="op">;</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        path<span class="op">.</span>push(<span class="st">&quot;tests/example3&quot;</span>)<span class="op">;</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(read_file(path)<span class="op">,</span> <span class="st">&quot;{&#39;;asd</span><span class="sc">\\</span><span class="st">n</span><span class="sc">\\</span><span class="st">t/}&quot;</span><span class="op">.</span>to_string())<span class="op">;</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Rust has a very powerful testing system, so I want to use this here.
While we don't <em>really</em> need to use tests, as all we're testing
is that Rust's internal standard library is working, but that's just the
nature of this very simple CTF challenge. Now you just need to run
<code>$ cargo run (file)</code> and you have the flag!</p>
<h2>References</h2>
<p>[0] - https://stackoverflow.com/a/48215530 [1] -
https://www.gnu.org/software/wget/ [2] -
https://en.wikipedia.org/wiki/Man_page [3] -
https://man7.org/linux/man-pages/man1/cat.1.html</p>
